﻿/*
    Slykuiper  - Motion Graphics Design
    Website & Portfolio - http://slykuiper.com
    Twitter - @slykuiper
    Instagram - @slykuiper
    Email - corbin@slykuiper.com
*/

var expressionNames = [];
var expressionCodes = [];
var expressionInfo = [];

function getExpressionInfo(expressionName){
    for(i=0;i<expressionNames.length;i++){
        if(expressionNames[i] == expressionName){return expressionInfo[i];}
    }
}

function applyExpression(expressionName){
    var thisLayer = app.project.activeItem.selectedLayers[0]; // selected layer
    var thisLayerProperties = app.project.activeItem.selectedProperties; // selected layer properties
    for(i=0;i<expressionNames.length;i++){
        if(expressionNames[i] == expressionName){ // found matching expression
            if(expressionName == "loopout pingpong" || expressionName == "loopout cycle" || expressionName == "Beam 3Dto2D" || expressionName == "path xpos offset"){
                //expression doesn't have any preset/sliders/controls
                thisLayerProperties[0].expression = expressionCodes[i];
            }else{
                // expression has presets/sliders/controls
                thisLayer.Effects.addProperty(expressionName);
                thisLayerProperties[0].expression = expressionCodes[i];
            }
        }
    }
}

function createExpression(name, code, info, hasControls){
    expressionNames.push(name);
    expressionCodes.push(code); 
    expressionInfo.push(info); 
}

// expressions with controls
createExpression("seamless wiggle loop", 
    '// name: seamless wiggle loop\n' +
    '// author: Dan Ebberts\n' +
    't = time % effect("seamless wiggle loop")("Loop Time");\n' +
    'wiggle1 = wiggle(effect("seamless wiggle loop")("Frequency"), effect("seamless wiggle loop")("Amplitude"), 1, 0.5, t);\n' +
    'wiggle2 = wiggle(effect("seamless wiggle loop")("Frequency"), effect("seamless wiggle loop")("Amplitude"), 1, 0.5, t - effect("seamless wiggle loop")("Loop Time"));\n' +
    'linear(t, 0, effect("seamless wiggle loop")("Loop Time"), wiggle1, wiggle2)', 
    "Seamlessly wiggle any layer property with variable frequency, amplitude, and loop time.");
createExpression("keyframe overshoot", 
    '// name: keyframe overshoot\n' +
    '// author: Dan Ebberts\n' +
    'n = 0;\n' +
    'if (numKeys > 0){\n' +
    '  n = nearestKey(time).index;\n' +
    '  if (key(n).time > time) n--;\n' +
    '}\n' +
    'if (n > 0){\n' +
    '  t = time - key(n).time;\n' +
    '  amp = velocityAtTime(key(n).time - .001);\n' +
    '  w = effect("keyframe overshoot")("Frequency")*Math.PI*2;\n' +
    '  value + amp*(Math.sin(t*w)/Math.exp(effect("keyframe overshoot")("Decay")*t)/w);\n' +
    '}else\n' +
    '  value',
    "Overshoot expression applied to a keyframed animation. Adjustable frequency and decay variables.");
createExpression("keyframe bounce back", 
    '// name: keyframe bounce back\n' +
    '// author: Dan Ebberts\n' +
    'e = effect("keyframe bounce back")("e");\n' +
    'g = effect("keyframe bounce back")("g");\n' +
    'nMax = effect("keyframe bounce back")("nMax");\n' +
    'n = 0;\n' +
    'if (numKeys > 0){\n' +
    '  n = nearestKey(time).index;\n' +
    '  if (key(n).time > time) n--;\n' +
    '}\n' +
    'if (n > 0){\n' +
    '  t = time - key(n).time;\n' +
    '  v = -velocityAtTime(key(n).time - .001)*e;\n' +
    '  vl = length(v);\n' +
    '  if (value instanceof Array){\n' +
    '    vu = (vl > 0) ? normalize(v) : [0,0,0];\n' +
    '  }else{\n' +
    '    vu = (v < 0) ? -1 : 1;\n' +
    '  }\n' +
    '  tCur = 0;\n' +
    '  segDur = 2*vl/g;\n' +
    '  tNext = segDur;\n' +
    '  nb = 1; // number of bounces\n' +
    '  while (tNext < t && nb <= nMax){\n' +
    '    vl *= e;\n' +
    '    segDur *= e;\n' +
    '    tCur = tNext;\n' +
    '    tNext += segDur;\n' +
    '    nb++\n' +
    '  }\n' +
    '  if(nb <= nMax){\n' +
    '    delta = t - tCur;\n' +
    '    value +  vu*delta*(vl - g*delta/2);\n' +
    '  }else{\n' +
    '    value\n' +
    '  }\n' +
    '}else\n' +
    '  value',
    "This expression uses a property's velocity coming into a keyframe to calculate a bounce-back (in the direction opposite to the incoming animation) with a series of diminishing bounces.");
createExpression("inertial bounce", 
    '// name: inertial bounce\n' +
    '// author: Dan Ebberts\n' +
    'n = 0;\n' +
    'if (numKeys > 0){\n' +
    'n = nearestKey(time).index;\n' +
    'if (key(n).time > time){\n' +
    'n--;}}\n' +
    'if (n == 0){\n' +
    't = 0;\n' +
    '}else{\n' +
    't = time - key(n).time;\n' +
    '}\n' +
    'if (n > 0 && t < 1){\n' +
    'v = velocityAtTime(key(n).time - thisComp.frameDuration/10);\n' +
    'value + v*effect("inertial bounce")("Amplitude")*Math.sin(effect("inertial bounce")("Frequency")*t*2*Math.PI)/Math.exp(effect("inertial bounce")("Decay")*t);\n' +
    '}else{\n' +
    'value;\n' +
    '}',
    "Bouncing animation from one keyframe to another.");
createExpression("circle path", 
    '// name: circle path\n' +
    '// author: Ewan Smith\n' +
    'x=effect("circle path")("Radius")*Math.cos(degreesToRadians(time*effect("circle path")("Speed")));\n' +
    'y=effect("circle path")("Radius")*Math.sin(degreesToRadians(time*effect("circle path")("Speed")));\n' +
    'z=0;\n' +
    'centre=[effect("circle path")("Center")[0],effect("circle path")("Center")[1],0];\n' +
    'add(centre,[x,y,z]);\n',
    "Apply on the position property of a layer. Moves the position layer in a circular motion with variables for radius amount and angle/speed.");
createExpression("spiral path", 
    '// name: spiral path\n' +
    '// author: Ewan Smith\n' +
    'shrink=time+1;\n' +
    'radius=effect("spiral path")("Radius")/shrink;\n' +
    'x=radius*Math.cos(degreesToRadians(time*effect("spiral path")("Speed")));\n' +
    'y=radius*Math.sin(degreesToRadians(time*effect("spiral path")("Speed")));\n' +
    'z=time*effect("spiral path")("Z-Rate");\n' +
    'centre=[effect("spiral path")("Center")[0],effect("spiral path")("Center")[1],0];\n' +
    'add(centre,[x,y,z]);\n',
    "Apply on the position property of a layer. Moves the position layer in a spiral motion with variables for radius amount, angle/speed, and shrink or grow (time-1).");
createExpression("rot based xpos", 
    '// name: rotation based on x position\n' +
    'x = transform.position[0]+effect("rot based xpos")("Distance");\n' +
    '(360*x/(Math.PI*width))*effect("rot based xpos")("Torque");', 
    "Rotate a layer based on its x position.");
createExpression("rot based ypos", 
    '// name: rotation based on y position\n' +
    'y = transform.position[1]+effect("rot based ypos")("Distance");\n' +
    '(360*y/(Math.PI*width))*torque = effect("rot based ypos")("Torque");', 
    "Rotate a layer based on its y position.");
createExpression("Angle Rotation Control", 
    '// name: Angle Rotation Control\n' +
    '// author: Mike Overbeck\n' +
    'var theRotator = effect("Angle Rotation Control")("Angle") % 360;\n' +
    'var theDuration = thisLayer.source.duration;\n' +
    'var rotFactor = theDuration / 360;\n' +
    'if(theRotator < 0){\n' +
    'theRotator = 360 + theRotator;\n' +
    '}\n' +
    'theRotator * rotFactor;',
    "Apply to layer's Time Remap. Creates an Angle Control on looped rotating source footage. Add an Angle Control expression control to the layer and link up to theRotator variable.");
// expression without controls
createExpression("loopout pingpong", 
    '// name: loopout pingpong\n' +
    'loopOut("pingpong");',
    "Loops a segment of time that is measured from the last keyframe on the layer back toward the In point of the layer. Repeats the specified segment, alternating between forward and backward.");
createExpression("loopout cycle", 
    '// name: loopout cycle\n' +
    'loopOut("cycle", 0);', 
    "Loops all keyframes in a cyclical manner, starting from first keyframe to last.");
createExpression("Beam 3Dto2D", 
    '// name: Beam 3Dto2D\n' +
    'L = layerhere;\n' +
    'L.toComp([0,0,0]);',
    "Use this on a solid layer with the Beam Effect applied, on the Starting Point and Ending Point. L needs to be the 3d layers in your comp.");
createExpression("path xpos offset", 
    '// name: trim path offset based on x position\n' +
    '// apply this to the shape layers trim path offset\n' +
    '// get pathLength from illustrator\n' +
    'pathScale = transform.scale[0]/100;\n' +
    'pathLength = 1000;\n' +
    'pathLength=pathLength*pathScale;\n' +
    'transform.position[0]/pathLength * 360;',
    "Apply to a shapelayer Trim Paths operator. Creates tracks/treads that appear to stay on ground and move in the correct motion. Get the pathLength variable from a path in Illustrator. Select the path, go to Window > Document Info > Dropdown Icon > Objects");